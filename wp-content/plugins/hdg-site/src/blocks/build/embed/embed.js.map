{"version":3,"file":"embed/embed.js","mappings":";;;;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,sEAAsE,aAAa;AACnF;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;;AAEA;AACA,2EAA2E,WAAW;AACtF,uEAAuE,WAAW;;AAElF;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,wBAAwB,sBAAsB;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,SAAS;AACT;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,yCAAyC,UAAU,iBAAiB,WAAW;AAC/E;AACA;AACA;AACA,iEAAiE,iCAAiC,GAAG,4BAA4B;AACjI;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2DAA2D,aAAa;AACxE;AACA,uCAAuC;AACvC,2CAA2C;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,qDAAqD,QAAQ;AAC7D;AACA,SAAS;AACT;AACA;AACA;AACA;;;;;;;;;;;;;AC7OA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2DAA2D;AAC3D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,UAAU,gBAAgB;AAC1B;AACA;AACA;AACA;;AAEA,4CAA4C,aAAa;AACzD;AACA;AACA;AACA,iEAAiE,MAAM,GAAG,OAAO;AACjF,6CAA6C,aAAa;AAC1D,OAAO;;AAEP;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,qCAAqC,UAAU,iBAAiB,WAAW;AAC3E;AACA;AACA,qDAAqD,iCAAiC;AACtF;;AAEA;AACA,wDAAwD,YAAY;AACpE;AACA;;AAEA;AACA;AACA;;AAEA;AACA,oBAAoB,sBAAsB;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB,YAAY,QAAQ;AACpB;AACA,kCAAkC,eAAe;AACjD;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;;;;;;UC9NA;UACA;;UAEA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;;UAEA;UACA;;UAEA;UACA;UACA;;;;;WCtBA;WACA;WACA;WACA;WACA;WACA,iCAAiC,WAAW;WAC5C;WACA;;;;;WCPA;WACA;WACA;WACA;WACA,yCAAyC,wCAAwC;WACjF;WACA;WACA;;;;;WCPA;;;;;WCAA;WACA;WACA;WACA,uDAAuD,iBAAiB;WACxE;WACA,gDAAgD,aAAa;WAC7D;;;;;;;;;;;;;;;ACN0B,CAAC;AACC,CAAC,yD","sources":["webpack://hdg/./node_modules/lite-youtube-embed/src/lite-yt-embed.js","webpack://hdg/./node_modules/lite-vimeo-embed/lite-vimeo-embed.js","webpack://hdg/webpack/bootstrap","webpack://hdg/webpack/runtime/compat get default export","webpack://hdg/webpack/runtime/define property getters","webpack://hdg/webpack/runtime/hasOwnProperty shorthand","webpack://hdg/webpack/runtime/make namespace object","webpack://hdg/./src/blocks/src/embed/embed.js"],"sourcesContent":["/**\n * A lightweight youtube embed. Still should feel the same to the user, just MUCH faster to initialize and paint.\n *\n * Thx to these as the inspiration\n *   https://storage.googleapis.com/amp-vs-non-amp/youtube-lazy.html\n *   https://autoplay-youtube-player.glitch.me/\n *\n * Once built it, I also found these:\n *   https://github.com/ampproject/amphtml/blob/master/extensions/amp-youtube (üëçüëç)\n *   https://github.com/Daugilas/lazyYT\n *   https://github.com/vb/lazyframe\n */\nclass LiteYTEmbed extends HTMLElement {\n    connectedCallback() {\n        this.videoId = this.getAttribute('videoid');\n\n        let playBtnEl = this.querySelector('.lty-playbtn');\n        // A label for the button takes priority over a [playlabel] attribute on the custom-element\n        this.playLabel = (playBtnEl && playBtnEl.textContent.trim()) || this.getAttribute('playlabel') || 'Play';\n\n        this.dataset.title = this.getAttribute('title') || \"\";\n\n        /**\n         * Lo, the youtube poster image!  (aka the thumbnail, image placeholder, etc)\n         *\n         * See https://github.com/paulirish/lite-youtube-embed/blob/master/youtube-thumbnail-urls.md\n         */\n        if (!this.style.backgroundImage) {\n          this.style.backgroundImage = `url(\"https://i.ytimg.com/vi/${this.videoId}/hqdefault.jpg\")`;\n          this.upgradePosterImage();\n        }\n\n        // Set up play button, and its visually hidden label\n        if (!playBtnEl) {\n            playBtnEl = document.createElement('button');\n            playBtnEl.type = 'button';\n            playBtnEl.classList.add('lty-playbtn');\n            this.append(playBtnEl);\n        }\n        if (!playBtnEl.textContent) {\n            const playBtnLabelEl = document.createElement('span');\n            playBtnLabelEl.className = 'lyt-visually-hidden';\n            playBtnLabelEl.textContent = this.playLabel;\n            playBtnEl.append(playBtnLabelEl);\n        }\n\n        this.addNoscriptIframe();\n\n        // for the PE pattern, change anchor's semantics to button\n        if(playBtnEl.nodeName === 'A'){\n            playBtnEl.removeAttribute('href');\n            playBtnEl.setAttribute('tabindex', '0');\n            playBtnEl.setAttribute('role', 'button');\n            // fake button needs keyboard help\n            playBtnEl.addEventListener('keydown', e => {\n                if( e.key === 'Enter' || e.key === ' ' ){\n                    e.preventDefault();\n                    this.activate();\n                }\n            });\n        }\n\n        // On hover (or tap), warm up the TCP connections we're (likely) about to use.\n        this.addEventListener('pointerover', LiteYTEmbed.warmConnections, {once: true});\n        this.addEventListener('focusin', LiteYTEmbed.warmConnections, {once: true});\n\n        // Once the user clicks, add the real iframe and drop our play button\n        // TODO: In the future we could be like amp-youtube and silently swap in the iframe during idle time\n        //   We'd want to only do this for in-viewport or near-viewport ones: https://github.com/ampproject/amphtml/pull/5003\n        this.addEventListener('click', this.activate);\n\n        // Chrome & Edge desktop have no problem with the basic YouTube Embed with ?autoplay=1\n        // However Safari desktop and most/all mobile browsers do not successfully track the user gesture of clicking through the creation/loading of the iframe,\n        // so they don't autoplay automatically. Instead we must load an additional 2 sequential JS files (1KB + 165KB) (un-br) for the YT Player API\n        // TODO: Try loading the the YT API in parallel with our iframe and then attaching/playing it. #82\n        this.needsYTApi = this.hasAttribute(\"js-api\") || navigator.vendor.includes('Apple') || navigator.userAgent.includes('Mobi');\n    }\n\n    /**\n     * Add a <link rel={preload | preconnect} ...> to the head\n     */\n    static addPrefetch(kind, url, as) {\n        const linkEl = document.createElement('link');\n        linkEl.rel = kind;\n        linkEl.href = url;\n        if (as) {\n            linkEl.as = as;\n        }\n        document.head.append(linkEl);\n    }\n\n    /**\n     * Begin pre-connecting to warm up the iframe load\n     * Since the embed's network requests load within its iframe,\n     *   preload/prefetch'ing them outside the iframe will only cause double-downloads.\n     * So, the best we can do is warm up a few connections to origins that are in the critical path.\n     *\n     * Maybe `<link rel=preload as=document>` would work, but it's unsupported: http://crbug.com/593267\n     * But TBH, I don't think it'll happen soon with Site Isolation and split caches adding serious complexity.\n     */\n    static warmConnections() {\n        if (LiteYTEmbed.preconnected) return;\n\n        // The iframe document and most of its subresources come right off youtube.com\n        LiteYTEmbed.addPrefetch('preconnect', 'https://www.youtube-nocookie.com');\n        // The botguard script is fetched off from google.com\n        LiteYTEmbed.addPrefetch('preconnect', 'https://www.google.com');\n\n        // Not certain if these ad related domains are in the critical path. Could verify with domain-specific throttling.\n        LiteYTEmbed.addPrefetch('preconnect', 'https://googleads.g.doubleclick.net');\n        LiteYTEmbed.addPrefetch('preconnect', 'https://static.doubleclick.net');\n\n        LiteYTEmbed.preconnected = true;\n    }\n\n    fetchYTPlayerApi() {\n        if (window.YT || (window.YT && window.YT.Player)) return;\n\n        this.ytApiPromise = new Promise((res, rej) => {\n            var el = document.createElement('script');\n            el.src = 'https://www.youtube.com/iframe_api';\n            el.async = true;\n            el.onload = _ => {\n                YT.ready(res);\n            };\n            el.onerror = rej;\n            this.append(el);\n        });\n    }\n\n    /** Return the YT Player API instance. (Public L-YT-E API) */\n    async getYTPlayer() {\n        if(!this.playerPromise) {\n            await this.activate();\n        }\n\n        return this.playerPromise;\n    }\n\n    async addYTPlayerIframe() {\n        this.fetchYTPlayerApi();\n        await this.ytApiPromise;\n\n        const videoPlaceholderEl = document.createElement('div')\n        this.append(videoPlaceholderEl);\n\n        const paramsObj = Object.fromEntries(this.getParams().entries());\n\n        this.playerPromise = new Promise(resolve => {\n            let player = new YT.Player(videoPlaceholderEl, {\n                width: '100%',\n                videoId: this.videoId,\n                playerVars: paramsObj,\n                events: {\n                    'onReady': event => {\n                        event.target.playVideo();\n                        resolve(player);\n                    }\n                }\n            });\n        });\n    }\n\n    // Add the iframe within <noscript> for indexability discoverability. See https://github.com/paulirish/lite-youtube-embed/issues/105\n    addNoscriptIframe() {\n        const iframeEl = this.createBasicIframe();\n        const noscriptEl = document.createElement('noscript');\n        // Appending into noscript isn't equivalant for mysterious reasons: https://html.spec.whatwg.org/multipage/scripting.html#the-noscript-element\n        noscriptEl.innerHTML = iframeEl.outerHTML;\n        this.append(noscriptEl);\n    }\n\n    getParams() {\n        const params = new URLSearchParams(this.getAttribute('params') || []);\n        params.append('autoplay', '1');\n        params.append('playsinline', '1');\n        return params;\n    }\n\n    async activate(){\n        if (this.classList.contains('lyt-activated')) return;\n        this.classList.add('lyt-activated');\n\n        if (this.needsYTApi) {\n            return this.addYTPlayerIframe(this.getParams());\n        }\n\n        const iframeEl = this.createBasicIframe();\n        this.append(iframeEl);\n\n        // Set focus for a11y\n        iframeEl.focus();\n    }\n\n    createBasicIframe(){\n        const iframeEl = document.createElement('iframe');\n        iframeEl.width = 560;\n        iframeEl.height = 315;\n        // No encoding necessary as [title] is safe. https://cheatsheetseries.owasp.org/cheatsheets/Cross_Site_Scripting_Prevention_Cheat_Sheet.html#:~:text=Safe%20HTML%20Attributes%20include\n        iframeEl.title = this.playLabel;\n        iframeEl.allow = 'accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture';\n        iframeEl.allowFullscreen = true;\n        // AFAIK, the encoding here isn't necessary for XSS, but we'll do it only because this is a URL\n        // https://stackoverflow.com/q/64959723/89484\n        iframeEl.src = `https://www.youtube-nocookie.com/embed/${encodeURIComponent(this.videoId)}?${this.getParams().toString()}`;\n        return iframeEl;\n    }\n\n    /**\n     * In the spirit of the `lowsrc` attribute and progressive JPEGs, we'll upgrade the reliable\n     * poster image to a higher resolution one, if it's available.\n     * Interestingly this sddefault webp is often smaller in filesize, but we will still attempt it second\n     * because getting _an_ image in front of the user if our first priority.\n     *\n     * See https://github.com/paulirish/lite-youtube-embed/blob/master/youtube-thumbnail-urls.md for more details\n     */\n    upgradePosterImage() {\n         // Defer to reduce network contention.\n        setTimeout(() => {\n            const webpUrl = `https://i.ytimg.com/vi_webp/${this.videoId}/sddefault.webp`;\n            const img = new Image();\n            img.fetchPriority = 'low'; // low priority to reduce network contention\n            img.referrerpolicy = 'origin'; // Not 100% sure it's needed, but https://github.com/ampproject/amphtml/pull/3940\n            img.src = webpUrl;\n            img.onload = e => {\n                // A pretty ugly hack since onerror won't fire on YouTube image 404. This is (probably) due to\n                // Youtube's style of returning data even with a 404 status. That data is a 120x90 placeholder image.\n                // ‚Ä¶ per \"annoying yt 404 behavior\" in the .md\n                const noAvailablePoster = e.target.naturalHeight == 90 && e.target.naturalWidth == 120;\n                if (noAvailablePoster) return;\n\n                this.style.backgroundImage = `url(\"${webpUrl}\")`;\n            }\n        }, 100);\n    }\n}\n// Register custom element\ncustomElements.define('lite-youtube', LiteYTEmbed);\n","const style = document.head.appendChild(document.createElement('style'));\nstyle.textContent = /*css*/`\n\n  lite-vimeo {\n    aspect-ratio: 16 / 9;\n    background-color: #000;\n    position: relative;\n    display: block;\n    contain: content;\n    background-position: center center;\n    background-size: cover;\n    cursor: pointer;\n  }\n\n  lite-vimeo > iframe {\n    width: 100%;\n    height: 100%;\n    position: absolute;\n    top: 0;\n    left: 0;\n    border: 0;\n  }\n\n  lite-vimeo > .ltv-playbtn {\n    font-size: 10px;\n    padding: 0;\n    width: 6.5em;\n    height: 4em;\n    background: rgba(23, 35, 34, .75);\n    z-index: 1;\n    opacity: .8;\n    border-radius: .5em;\n    transition: opacity .2s ease-out, background .2s ease-out;\n    outline: 0;\n    border: 0;\n    cursor: pointer;\n  }\n\n  lite-vimeo:hover > .ltv-playbtn {\n    background-color: rgb(0, 173, 239);\n    opacity: 1;\n  }\n\n  /* play button triangle */\n  lite-vimeo > .ltv-playbtn::before {\n    content: '';\n    border-style: solid;\n    border-width: 10px 0 10px 20px;\n    border-color: transparent transparent transparent #fff;\n  }\n\n  lite-vimeo > .ltv-playbtn,\n  lite-vimeo > .ltv-playbtn::before {\n    position: absolute;\n    top: 50%;\n    left: 50%;\n    transform: translate3d(-50%, -50%, 0);\n  }\n\n  /* Post-click styles */\n  lite-vimeo.ltv-activated {\n    cursor: unset;\n  }\n\n  lite-vimeo.ltv-activated::before,\n  lite-vimeo.ltv-activated > .ltv-playbtn {\n    opacity: 0;\n    pointer-events: none;\n  }\n`;\n\n/**\n * Ported from https://github.com/paulirish/lite-youtube-embed\n *\n * A lightweight vimeo embed. Still should feel the same to the user, just MUCH faster to initialize and paint.\n *\n * Thx to these as the inspiration\n *   https://storage.googleapis.com/amp-vs-non-amp/youtube-lazy.html\n *   https://autoplay-youtube-player.glitch.me/\n *\n * Once built it, I also found these:\n *   https://github.com/ampproject/amphtml/blob/master/extensions/amp-youtube (üëçüëç)\n *   https://github.com/Daugilas/lazyYT\n *   https://github.com/vb/lazyframe\n */\nclass LiteVimeo extends (globalThis.HTMLElement ?? class {}) {\n  /**\n   * Begin pre-connecting to warm up the iframe load\n   * Since the embed's network requests load within its iframe,\n   *   preload/prefetch'ing them outside the iframe will only cause double-downloads.\n   * So, the best we can do is warm up a few connections to origins that are in the critical path.\n   *\n   * Maybe `<link rel=preload as=document>` would work, but it's unsupported: http://crbug.com/593267\n   * But TBH, I don't think it'll happen soon with Site Isolation and split caches adding serious complexity.\n   */\n  static _warmConnections() {\n    if (LiteVimeo.preconnected) return;\n    LiteVimeo.preconnected = true;\n\n    // The iframe document and most of its subresources come right off player.vimeo.com\n    addPrefetch('preconnect', 'https://player.vimeo.com');\n    // Images\n    addPrefetch('preconnect', 'https://i.vimeocdn.com');\n    // Files .js, .css\n    addPrefetch('preconnect', 'https://f.vimeocdn.com');\n    // Metrics\n    addPrefetch('preconnect', 'https://fresnel.vimeocdn.com');\n  }\n\n  connectedCallback() {\n    this.videoId = this.getAttribute('videoid');\n\n    /**\n     * Lo, the vimeo placeholder image!  (aka the thumbnail, poster image, etc)\n     * We have to use the Vimeo API.\n     */\n    let { width, height } = getThumbnailDimensions(this.getBoundingClientRect());\n    let devicePixelRatio = window.devicePixelRatio || 1;\n    if (devicePixelRatio >= 2) devicePixelRatio *= .75;\n    width = Math.round(width * devicePixelRatio);\n    height = Math.round(height * devicePixelRatio);\n\n    fetch(`https://vimeo.com/api/v2/video/${this.videoId}.json`)\n      .then(response => response.json())\n      .then(data => {\n        let thumbnailUrl = data[0].thumbnail_large;\n        thumbnailUrl = thumbnailUrl.replace(/-d_[\\dx]+$/i, `-d_${width}x${height}`);\n        this.style.backgroundImage = `url(\"${thumbnailUrl}\")`;\n      });\n\n    let playBtnEl = this.querySelector('.ltv-playbtn');\n    // A label for the button takes priority over a [playlabel] attribute on the custom-element\n    this.playLabel = (playBtnEl && playBtnEl.textContent.trim()) || this.getAttribute('playlabel') || 'Play video';\n\n    if (!playBtnEl) {\n      playBtnEl = document.createElement('button');\n      playBtnEl.type = 'button';\n      playBtnEl.setAttribute('aria-label', this.playLabel);\n      playBtnEl.classList.add('ltv-playbtn');\n      this.append(playBtnEl);\n    }\n    playBtnEl.removeAttribute('href');\n\n    // On hover (or tap), warm up the TCP connections we're (likely) about to use.\n    this.addEventListener('pointerover', LiteVimeo._warmConnections, {\n      once: true\n    });\n\n    // Once the user clicks, add the real iframe and drop our play button\n    // TODO: In the future we could be like amp-youtube and silently swap in the iframe during idle time\n    //   We'd want to only do this for in-viewport or near-viewport ones: https://github.com/ampproject/amphtml/pull/5003\n    this.addEventListener('click', this.addIframe);\n  }\n\n  addIframe() {\n    if (this.classList.contains('ltv-activated')) return;\n    this.classList.add('ltv-activated');\n\n    const iframeEl = document.createElement('iframe');\n    iframeEl.width = 640;\n    iframeEl.height = 360;\n    // No encoding necessary as [title] is safe. https://cheatsheetseries.owasp.org/cheatsheets/Cross_Site_Scripting_Prevention_Cheat_Sheet.html#:~:text=Safe%20HTML%20Attributes%20include\n    iframeEl.title = this.playLabel;\n    iframeEl.allow = 'accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture';\n    // AFAIK, the encoding here isn't necessary for XSS, but we'll do it only because this is a URL\n    // https://stackoverflow.com/q/64959723/89484\n    iframeEl.src = `https://player.vimeo.com/video/${encodeURIComponent(this.videoId)}?autoplay=1`;\n    this.append(iframeEl);\n\n    // Set focus for a11y\n    iframeEl.addEventListener('load', iframeEl.focus, { once: true });\n  }\n}\n\nif (globalThis.customElements && !globalThis.customElements.get('lite-vimeo')) {\n  globalThis.customElements.define('lite-vimeo', LiteVimeo);\n}\n\n/**\n * Add a <link rel={preload | preconnect} ...> to the head\n */\nfunction addPrefetch(kind, url, as) {\n  const linkElem = document.createElement('link');\n  linkElem.rel = kind;\n  linkElem.href = url;\n  if (as) {\n    linkElem.as = as;\n  }\n  linkElem.crossorigin = true;\n  document.head.append(linkElem);\n}\n\n/**\n * Get the thumbnail dimensions to use for a given player size.\n *\n * @param {Object} options\n * @param {number} options.width The width of the player\n * @param {number} options.height The height of the player\n * @return {Object} The width and height\n */\nfunction getThumbnailDimensions({ width, height }) {\n  let roundedWidth = width;\n  let roundedHeight = height;\n\n  // If the original width is a multiple of 320 then we should\n  // not round up. This is to keep the native image dimensions\n  // so that they match up with the actual frames from the video.\n  //\n  // For example 640x360, 960x540, 1280x720, 1920x1080\n  //\n  // Round up to nearest 100 px to improve cacheability at the\n  // CDN. For example, any width between 601 pixels and 699\n  // pixels will render the thumbnail at 700 pixels width.\n  if (roundedWidth % 320 !== 0) {\n    roundedWidth = Math.ceil(width / 100) * 100;\n    roundedHeight = Math.round((roundedWidth / width) * height);\n  }\n\n  return {\n    width: roundedWidth,\n    height: roundedHeight\n  };\n}\n","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","// getDefaultExport function for compatibility with non-harmony modules\n__webpack_require__.n = (module) => {\n\tvar getter = module && module.__esModule ?\n\t\t() => (module['default']) :\n\t\t() => (module);\n\t__webpack_require__.d(getter, { a: getter });\n\treturn getter;\n};","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","// define __esModule on exports\n__webpack_require__.r = (exports) => {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};","import 'lite-vimeo-embed'; //Youtube embed - https://github.com/paulirish/lite-youtube-embed\nimport 'lite-youtube-embed'; //Vimeo embed - https://github.com/slightlyoff/lite-vimeo"],"names":[],"sourceRoot":""}